% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Calculate_distances_functions.R
\name{dist.obstacle}
\alias{dist.obstacle}
\title{Calculate 2D distances from points to points avoiding obstacles}
\usage{
dist.obstacle(from, to, r.ref, dref.r, n.cores, closest = FALSE,
  step.ang = 5, r.ref3D = FALSE, filename = paste0(tempdir(),
  "/dref.r.RData"), small.dist = TRUE, keep.path = FALSE,
  longlat = raster::isLonLat(r.ref), tol = 1e-05, igraph = FALSE)
}
\arguments{
\item{from}{Point data set from which to calculate distances. May be a 2-col
matrix of (x,y) coordinates or a SpatialPointDataFrame. Should be in same
projection than r.ref. This can also be an object of class distref.data.}

\item{to}{Point data set from which to calculate distances. May be a 2-col
matrix of (x,y) coordinates or a SpatialPointDataFrame. Should be in same
projection than r.ref. If not set to = from. This can also be an object of
class distref.data. If "to" is provided, it should be the bigger dataset.}

\item{r.ref}{reference raster used for distance without obstacles calculation}

\item{dref.r}{object of class distref.raster. Reference raster already
processed using distref.raster (e.g. usefull if previously saved using filename.)}

\item{n.cores}{number of cores to run parallel calculation. Default to all
cores using parallel::detectCores()}

\item{closest}{if a point is over an obstacle, set to TRUE to find the closest
non-obstacle r.ref cell}

\item{step.ang}{Step for angles classes breaks (in degrees). This means that
a distance error is allowed in future calculations.
Distance error (\%) = 100 * (1 - cos((step.ang/2)*pi/180)).
With step.ang = 5 degrees, error < 0.1\%. Default set to 5.}

\item{r.ref3D}{Logical. Wether the reference raster should be used as a 3D
surface to calculate distance accounting for elevation.}

\item{filename}{Path where to save the dref.r issued from reference raster.
This may be usefull for re-using the raster for different datasets. Default
to paste0(tempdir(),"/dref.r.RData")}

\item{small.dist}{if TRUE, distances <= 1 paths are directly calculated.}

\item{keep.path}{Logical. Whether to keep SpatialLines of paths.
This allows real distances when 2 points are in the same raster cell or close.}

\item{longlat}{Logical. if FALSE, Euclidean distance, if TRUE Great Circle
distance. Defined from r.ref.}

\item{tol}{numeric Tolerance to define distances between points to be null.}

\item{igraph}{Logical. Wether to calculate all distances through igraph (TRUE)
or use \code{\link{Pt2Pts.wo.obstacle}} to use igraph only when necessary.
Using igraph maybe less precise but a little quicker. Default to FALSE.}
}
\value{
If keep.path is false, returns a matrix of distances with rows = "from"
and cols = "to".
If keep.path is true, returns a list where dist.mat is the matrix of distance
and listLines is a list of SpatialLines. Each list is a SpatialLinesDataFrame
corresponding to a starting point in "from".
}
\description{
Calculate 2D distances from points to points avoiding obstacles
}
\examples{
\dontrun{
# For "from" and "to" being SpatialPoints
allpath <- dist.obstacle(from, to, r.ref, keep.path = TRUE)
plot(from)
points(to)
# All path from "from[1,]" to all "to"
lines(allpath$allLines[[1]])
}
}
